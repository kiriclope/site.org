<!DOCTYPE html>
<html lang="en">
<head>
<!-- 22 Sep. 2023 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Introduction to Qiskit</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Alexandre Mahrach">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-1687066-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-1687066-2');
</script>
<link href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css' rel='stylesheet' integrity='sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==' crossorigin='anonymous'/>
<meta description='The blog of Alexandre Mahrach'/>
<link rel='alternate' type='application+rss/xml' title='The blog of Alexandre Mahrach' href='posts/rss.xml'/>
<link rel="stylesheet" href="../../css/site.css?v=79be7c3915af85fc6b1983f9ba00965d5644c3c4763ea82d3499424d07a026a6" type="text/css">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<header id="preamble" class="status">
<div class="logo">
  <a href="/">
    <img src="/snippets/images/photo.png" class="avatar" alt="My photo"/>
  </a>
  <div class="title-section">
    <a href="/"><h1>Alexandre Mahrach</h1></a>
    <!-- <sub style="line-height:1;"> <h2>Data Scientist & Machine Learning Expert</h2> </sub> -->
    <nav>
      <ul>
        <li><a href="/posts/posts.html"> Posts </a></li>
        <li><a href="/tutorials/tutorials.html"> Tutorials </a></li>
        <li><a href="/about.html"> About </a></li>
        <!-- add more as needed -->
      </ul>
    </nav>
  </div>
  <div id="social">
    <a title="kiriclope on Github" href="https://github.com/kiriclope">
      <i class="fa-brands fa-github"></i>
    </a>
    <a title="amahrach on LinkedIn" href="https://linkedin.com/in/amahrach">
      <i class="fa-brands fa-linkedin"></i>
    </a>
    <!-- <a title="dmacvicar on Twitter" href="https://twitter.com/dmacvicar"> -->
      <!--   <i class="fa-brands fa-twitter"></i> -->
      <!-- </a> -->
    <a title="RSS feed" id="atom" href="posts/rss.xml">
      <i class="fa-solid fa-rss"></i>
    </a>
  </div>
</div>
</header>
<main id="content">
<header>
<h1 class="title">Introduction to Qiskit</h1>
<p class="subtitle">Sep 22, 2023</p>
</header>
<section id="outline-container-org994e385" class="outline-2">
<h2 id="org994e385">Intro to Qiskit</h2>
<div class="outline-text-2" id="text-org994e385">
<div class="org-src-container">
<pre class="src src-ipython">import numpy as np

# Importing standard Qiskit libraries
from qiskit import QuantumCircuit, transpile, assemble, Aer, IBMQ, execute
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector, plot_histogram
from qiskit_textbook.problems import dj_problem_oracle
</pre>
</div>
</div>

<div id="outline-container-org2a4f517" class="outline-3">
<h3 id="org2a4f517">Basic Rotations on One Qubit and Measurements on the Bloch Sphere</h3>
<div class="outline-text-3" id="text-org2a4f517">
<p>
Before getting into complicated circuits on many qubits, let us start by looking at a single qubit. Read this chapter: <a href="https://qiskit.org/textbook/ch-states/introduction.html">https://qiskit.org/textbook/ch-states/introduction.html</a> to learn the basics about the Bloch sphere, Pauli operators, as well as the Hadamard gate and the \(S\) and \(S^\dagger\) gates. 
</p>

<p>
By default, states in qiskit start in \(|0\rangle\), which corresponds to &ldquo;arrow up&rdquo; on the Bloch sphere. Play around with the gates \(X\), \(Y\), \(Z\), \(H\), \(S\) and \(S^\dagger\) to get a feeling for the different rotations. To do so, insert combinations of the following code lines in the lines indicated in the program:
</p>

<p>
qc.x(0)    # rotation by Pi around the x-axis
qc.y(0)    # rotation by Pi around the y-axis
qc.z(0)    # rotation by Pi around the z-axis
qc.s(0)    # rotation by Pi/2 around the z-axis
qc.sdg(0)  # rotation by -Pi/2 around the z-axis
qc.h(0)    # rotation by Pi around an axis located halfway between x and z
</p>
</div>

<div id="outline-container-org4e0bef8" class="outline-4">
<h4 id="org4e0bef8">1.) Let us start easy by performing a bit flip. The goal is to reach the state \(|1\rangle\).</h4>
<div class="outline-text-4" id="text-org4e0bef8">
<div class="org-src-container">
<pre class="src src-ipython">qc = QuantumCircuit(1)
qc.x(0)
state = Statevector.from_instruction(qc)
plot_bloch_multivector(state)  
</pre>
</div>


<figure id="org5288f83">
<img src="./.ob-jupyter/0a354ed8ae7b7a4718420759c96092bcfb7d43a9.png" alt="0a354ed8ae7b7a4718420759c96092bcfb7d43a9.png">

</figure>
</div>
</div>

<div id="outline-container-org952d792" class="outline-4">
<h4 id="org952d792">2.) Next, we would like to create superposition. The goal is to reach the state \(|+\rangle = \frac{1}{\sqrt{2}}\left(|0\rangle + |1\rangle\right)\).</h4>
<div class="outline-text-4" id="text-org952d792">
<div class="org-src-container">
<pre class="src src-ipython">qc = QuantumCircuit(1)
qc.h(0)  
state = Statevector.from_instruction(qc)
plot_bloch_multivector(state)
</pre>
</div>


<figure id="orgdaf01e7">
<img src="./.ob-jupyter/1e72693ded722b88f666b81e8152f8aefe15f330.png" alt="1e72693ded722b88f666b81e8152f8aefe15f330.png">

</figure>
</div>
</div>

<div id="outline-container-org352a53f" class="outline-4">
<h4 id="org352a53f">3.) Let&rsquo;s combine those two. The goal is to reach the state \(|-\rangle = \frac{1}{\sqrt{2}}\left(|0\rangle - |1\rangle\right)\).</h4>
<div class="outline-text-4" id="text-org352a53f">
<div class="org-src-container">
<pre class="src src-ipython">qc = QuantumCircuit(1)
qc.x(0)
qc.h(0)  
state = Statevector.from_instruction(qc)
plot_bloch_multivector(state)
</pre>
</div>


<figure id="org7b6640b">
<img src="./.ob-jupyter/52421ba72088ea5e243f54719401e1a2a4208f72.png" alt="52421ba72088ea5e243f54719401e1a2a4208f72.png">

</figure>
</div>
</div>

<div id="outline-container-orgbd811da" class="outline-4">
<h4 id="orgbd811da">4.) Finally, we move on to the complex numbers. The goal is to reach the state \(|- i\rangle = \frac{1}{\sqrt{2}}\left(|0\rangle - i|1\rangle\right)\).</h4>
<div class="outline-text-4" id="text-orgbd811da">
<div class="org-src-container">
<pre class="src src-ipython">qc = QuantumCircuit(1)
qc.h(0)
# qc.y(0)
# qc.s(0)
qc.sdg(0)
state = Statevector.from_instruction(qc)
plot_bloch_multivector(state)
</pre>
</div>


<figure id="org67b0491">
<img src="./.ob-jupyter/f88ec8ef08e8656cd717237a90c20c3f87855635.png" alt="f88ec8ef08e8656cd717237a90c20c3f87855635.png">

</figure>
</div>
</div>
</div>

<div id="outline-container-org177aba1" class="outline-3">
<h3 id="org177aba1">Quantum Circuits Using Multi-Qubit Gates</h3>
<div class="outline-text-3" id="text-org177aba1">
<p>
Great job! Now that you&rsquo;ve understood the single-qubit gates, let us look at gates on multiple qubits. Check out this chapter if you would like to refresh the theory: <a href="https://qiskit.org/textbook/ch-gates/introduction.html">https://qiskit.org/textbook/ch-gates/introduction.html</a>.
</p>

<p>
The basic gates on two and three qubits are given by
</p>

<p>
qc.cx(c,t)       # controlled-X (= CNOT) gate with control qubit c and target qubit t
qc.cz(c,t)       # controlled-Z gate with control qubit c and target qubit t
qc.ccx(c1,c2,t)  # controlled-controlled-X (= Toffoli) gate with control qubits c1 and c2 and target qubit t
qc.swap(a,b)     # SWAP gate that swaps the states of qubit a and qubit b
</p>

<p>
We start with an easy gate on two qubits, the controlled-NOT (also CNOT) gate . As it has no effect applied on two qubits in state \(|0\rangle\), we apply a Hadamard gate before to bring the control qubit in superposition. This way, we can create entanglement. The resulting state is one of the so-called Bell states. 
</p>
</div>

<div id="outline-container-org3791e4f" class="outline-4">
<h4 id="org3791e4f">5.) Construct the Bell state \(|\Psi^+\rangle = \frac{1}{\sqrt{2}}\left(|01\rangle + |10\rangle\right)\).</h4>
<div class="outline-text-4" id="text-org3791e4f">
<div class="org-src-container">
<pre class="src src-ipython">qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)
qc.cx(0, 1)
qc.draw('mpl')
</pre>
</div>


<figure id="orgdeeafff">
<img src="./.ob-jupyter/d8ad5f1ec8dde9080eb4a1d55a28cd4b96890b35.png" alt="d8ad5f1ec8dde9080eb4a1d55a28cd4b96890b35.png">

</figure>

<p>
Let us now also add a measurement to the above circuit so that we can execute it (using the simulator) and plot the histogram of the corresponding counts.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qc.measure_all() # we measure all the qubits
backend = Aer.get_backend('qasm_simulator') # we choose the simulator as our backend
counts = execute(qc, backend, shots = 1000).result().get_counts() # we run the simulation and get the counts
plot_histogram(counts) # let us plot a histogram to see the possible out
</pre>
</div>


<figure id="orgb6f82d0">
<img src="./.ob-jupyter/6226a4d3a5b5d0d3f0922e906395148b7c703acd.png" alt="6226a4d3a5b5d0d3f0922e906395148b7c703acd.png">

</figure>

<p>
As you can see in the histogram, the only possible outputs are &ldquo;01&rdquo; and &ldquo;10&rdquo;, so the states of the two qubits are always perfectly anti-correlated.
</p>
</div>
</div>


<div id="outline-container-org9dc73c8" class="outline-4">
<h4 id="org9dc73c8">6.) Write a function that builds a quantum circuit on 3 qubits and creates the GHZ-like state, \(|\Psi\rangle = \frac{1}{\sqrt{2}} \left(|010\rangle - |101 \rangle \right)\).</h4>
<div class="outline-text-4" id="text-org9dc73c8">
<p>
Hint: the following circuit constructs the GHZ state, \(|GHZ\rangle = \frac{1}{\sqrt{2}} \left(|000\rangle + |111 \rangle \right)\):
</p>

<div class="org-src-container">
<pre class="src src-ipython">qc = QuantumCircuit(3)
qc.h(0)
qc.x(1)
qc.x(2)
qc.cx(0,1)
qc.cx(1,2)
qc.draw('mpl')
</pre>
</div>


<figure id="org70f9ae1">
<img src="./.ob-jupyter/5da0cc4bb5f75ee0974b4d79ea629d0bd2fce133.png" alt="5da0cc4bb5f75ee0974b4d79ea629d0bd2fce133.png">

</figure>

<div class="org-src-container">
<pre class="src src-ipython">qc.measure_all() # we measure all the qubits
backend = Aer.get_backend('qasm_simulator') # we choose the simulator as our backend
counts = execute(qc, backend, shots = 1000).result().get_counts() # we run the simulation and get the counts
plot_histogram(counts) # let us plot a histogram to see the 
</pre>
</div>


<figure id="orge666a38">
<img src="./.ob-jupyter/ee6627bf3a28adfe19cb11dff0840724d8ed8715.png" alt="ee6627bf3a28adfe19cb11dff0840724d8ed8715.png">

</figure>

<p>
Congratulations for finishing these introductory exercises! Hopefully, they got you more familiar with the Bloch sphere and basic quantum gates. Let us now apply this knowledge to the second part, where we construct our first quantum algorithm, the Deutsch-Jozsa algorithm.
</p>
</div>
</div>
</div>
</section>

<section id="outline-container-org6c7b354" class="outline-2">
<h2 id="org6c7b354">Oracles and the Deutsch-Jozsa algorithm</h2>
<div class="outline-text-2" id="text-org6c7b354">
<p>
Many quantum algoritms revolve around the notion of so called \(\textit{oracles}\). An oracle is a function that can be considered as a &rsquo;black box&rsquo;. We generally want to find out specific properties of this function. We do this by asking questions to the oracle (<b>querying</b>). The query complexity is then defined as the minimum number of queries in order to find these properties.
</p>

<p>
To get familiar with the use of oracles we will now consider the Deutsch-Josza problem. We will see that the quantum solution has a drastically lower query complexity than its classical counterpart.
</p>
</div>

<div id="outline-container-orga476233" class="outline-3">
<h3 id="orga476233">Deutsch-Jozsa Problem</h3>
<div class="outline-text-3" id="text-orga476233">
<p>
We are given a hidden Boolean function \(f\), which takes as input a string of bits, and returns either \(0\) or \(1\), that is:
</p>

<p>
\[
f(\{x_0,x_1,x_2,...\}) \rightarrow 0 \textrm{ or } 1 \textrm{ , where } x_n \textrm{ is } 0 \textrm{ or } 1\]
</p>

<p>
The property of the given Boolean function is that it is guaranteed to either be balanced or constant. A constant function returns all \(0\)&rsquo;s or all \(1\)&rsquo;s for any input, while a balanced function returns \(0\)&rsquo;s for exactly half of all inputs and \(1\)&rsquo;s for the other half. Our task is to determine whether the given function is balanced or constant.
</p>

<p>
The Deutsch-Jozsa algorithm was the first example of a quantum algorithm that performs better than the best classical algorithm. It showed that there can be advantages to using a quantum computer as a computational tool for a specific problem.
</p>

<p>
In the Deutsch-Josza problem you are given an unknown orcale. This is in Qiskit implemented by the function:
</p>

<div class="org-src-container">
<pre class="src src-ipython">oraclenr = 4 # determines the oracle (can range from 1 to 5)
oracle = dj_problem_oracle(oraclenr) # gives one out of 5 oracles
oracle.name = "DJ-Oracle"
</pre>
</div>

<p>
This function gives a certain oracle with 5 input qubits. The last qubit (\(q_4\)) will be the output. In order to get a feeling for the oracle, let us create a circuit to which we add the oracle such that we can pass it different input strings and then measure the output of \(q_4\). This corresponds to the classical way of determining whether the oracle is balanced or constant.
</p>

<div class="org-src-container">
<pre class="src src-ipython">def dj_classical(n, input_str):

    # build a quantum circuit with n qubits and 1 classical readout bit
    dj_circuit = QuantumCircuit(n+1,1)

    # Prepare the initial state corresponding to your input bit string
    for i in range(n):
	if input_str[i] == '1':
	    dj_circuit.x(i)

    # append oracle
    dj_circuit.append(oracle, range(n+1))

    # measure the fourth qubit 
    dj_circuit.measure(n,0)

    return dj_circuit

n = 4 # number of qubits
input_str = '1111'
dj_circuit = dj_classical(n, input_str)
dj_circuit.draw('mpl') # draw the circuit
</pre>
</div>


<figure id="org285a59e">
<img src="./.ob-jupyter/9abc8a482b13d1e1fe9968d1867047a160ec5182.png" alt="9abc8a482b13d1e1fe9968d1867047a160ec5182.png">

</figure>

<p>
Now we simulate the results to find the outcome of this circuit. Try different input bit strings to see the corresponding outputs!
</p>

<div class="org-src-container">
<pre class="src src-ipython">input_str = '1011'
dj_circuit = dj_classical(n, input_str)
qasm_sim = Aer.get_backend('qasm_simulator')
transpiled_dj_circuit = transpile(dj_circuit, qasm_sim)
qobj = assemble(transpiled_dj_circuit, qasm_sim)
results = qasm_sim.run(qobj).result()
answer = results.get_counts()
</pre>
</div>

<p>
/tmp/ipykernel_318198/847504298.py:6: DeprecationWarning: Using a qobj for run() is deprecated as of qiskit-aer 0.9.0 and will be removed no sooner than 3 months from that release date. Transpiled circuits should now be passed directly using `backend.run(circuits, **run_options).
  results = qasm_sim.run(qobj).result()
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_histogram(answer)
</pre>
</div>


<figure id="orgd02f0a0">
<img src="./.ob-jupyter/028f426ce0e9e8a9a25dad3c3bcf794a0a62768b.png" alt="028f426ce0e9e8a9a25dad3c3bcf794a0a62768b.png">

</figure>


<figure id="org2b1127d">
<img src="./.ob-jupyter/028f426ce0e9e8a9a25dad3c3bcf794a0a62768b.png" alt="028f426ce0e9e8a9a25dad3c3bcf794a0a62768b.png">

</figure>

<p>
Do you already have an idea whether the oracle is balanced or constant? What is the minimum and maximum number of inputs you would need to check to know whether this 4 bit classical Deutsch-Josza oracle is balanced or constant?
</p>

<div class="org-src-container">
<pre class="src src-ipython">min_nr_inputs = 2 #
max_nr_inputs = 9 # 2^4 + 1
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd2fa436" class="outline-3">
<h3 id="orgd2fa436">Quantum Solution to the Deutsch-Josza Problem</h3>
<div class="outline-text-3" id="text-orgd2fa436">
<p>
Using a quantum computer, we can find out if the oracle is constant or balanced with 100% confidence after only one call to the function \(f(x)\), provided we have the function \(f\) implemented as a quantum oracle, which maps the state $&vert; x&rang; &vert; y&rang; $ to $ &vert; x&rang; &vert; y &oplus; f(x)&rang;$, where \(\oplus\) is addition modulo \(2\). Below we will walk through the algorithm.
</p>

<p>
Prepare two quantum registers. The first is an $n$-qubit register initialised to \(|0\rangle\), and the second is a one-qubit register initialised to \(|-\rangle =\frac{1}{\sqrt{2}}\left(|0\rangle - |1 \rangle \right)\). Note, that with Qiskit states are described as \(\vert b_3 b_2 b_1 b_0\rangle_{q_3q_2q_1q_0}\), i.e. just like for binary numbers, the last bit \(b_0\) corresponds to the state of the first qubit. Thus, we want to initialize the state \[\vert \psi_0 \rangle = \vert -\rangle \otimes \vert0\rangle^{\otimes n}.\]
</p>

<div class="org-src-container">
<pre class="src src-ipython">def psi_0(n):
    qc = QuantumCircuit(n+1,n)

    # Build the state (|00000&gt; - |10000&gt;)/sqrt(2)
    qc.x(n)
    qc.h(n)
    return qc

dj_circuit = psi_0(n=4)
dj_circuit.draw('mpl')
</pre>
</div>


<figure id="orge557e19">
<img src="./.ob-jupyter/d008d29c789e516243311b2b55f25ebe94518bd0.png" alt="d008d29c789e516243311b2b55f25ebe94518bd0.png">

</figure>

<p>
Applying the quantum bit oracle to any state \(\vert x\rangle \vert y\rangle\) would yield the state \(\vert x\rangle \vert y \oplus f(x)\rangle\).
As we have prepared the state \(|y\rangle\), which corresponds to the state on the last qubit \(q_n\), in the state \(|-\rangle\), the output of the oracle for any input bitstring \(x\) is given by:
\[ \frac{1}{\sqrt{2}}\vert x\rangle (\vert f(x)\rangle - \vert 1 \oplus f(x)\rangle) = \frac{1}{\sqrt{2}} (-1)^{f(x)}|x\rangle (|0\rangle - |1\rangle ) = (-1)^{f(x)}|x\rangle |-\rangle.\]
Thus, we have created a phase oracle acting on the bit string \(x\).
</p>

<p>
Before applying the oracle, we need to create our input state on the first \(n\) qubits though. For that we want an equal superposition state, so that the total state on all \(n+1\) qubits is given by \[\vert \psi_1 \rangle = \frac{1}{\sqrt{2^{n+1}}}\sum_{x=0}^{2^n-1} \vert x\rangle \left(|0\rangle - |1 \rangle \right)\] 
</p>

<div class="org-src-container">
<pre class="src src-ipython">def psi_1(n):

    # obtain the |psi_0&gt; = (|00000&gt; - |10000&gt;)/sqrt(2) state
    qc = psi_0(n)

    # create the superposition state |psi_1&gt;
    for qubit in range(n):
	qc.h(qubit)
    return qc

dj_circuit = psi_1(n=4)
dj_circuit.draw('mpl')
</pre>
</div>


<figure id="org36d3dfe">
<img src="./.ob-jupyter/ca3b3c3f4ab5299bba6848f1047084b5946a3a77.png" alt="ca3b3c3f4ab5299bba6848f1047084b5946a3a77.png">

</figure>

<p>
Now we are ready to apply our oracle to the prepared superposition state \(\vert \psi_1 \rangle\). This gives the state
\[ \vert \psi_2 \rangle = \frac{1}{\sqrt{2^{n+1}}}\sum_{x=0}^{2^n-1} \vert x\rangle (\vert f(x)\rangle - \vert 1 \oplus f(x)\rangle) = \frac{1}{\sqrt{2^{n+1}}}\sum_{x=0}^{2^n-1}(-1)^{f(x)}|x\rangle (|0\rangle - |1\rangle ) = \frac{1}{\sqrt{2^{n}}}\sum_{x=0}^{2^n-1}(-1)^{f(x)}|x\rangle |-\rangle.\]
</p>

<div class="org-src-container">
<pre class="src src-ipython">def psi_2(oracle,n):

    # circuit to obtain psi_1
    qc = psi_1(n)

    # append the oracle
    qc.append(oracle, range(n+1))

    return qc

dj_circuit = psi_2(oracle, n=4)
dj_circuit.draw('mpl')
</pre>
</div>


<figure id="orgcc59c93">
<img src="./.ob-jupyter/c6e477e5e49c318ca753cf7cbc4af82fedf7b20b.png" alt="c6e477e5e49c318ca753cf7cbc4af82fedf7b20b.png">

</figure>

<p>
In the final part of our algorithm we disregard the outcome on our second register and we apply an n-fold Hadamard to our first register. Afterwards we measure the outcome on these qubits.
</p>

<div class="org-src-container">
<pre class="src src-ipython">def lab1_ex8(oracle, n): # note that this exercise also depends on the code in the functions psi_0 (In [24]) and psi_1 (In [25])
    qc = psi_2(oracle, n)

    # apply n-fold hadamard gate
    for qubit in range(n):
	qc.h(qubit)  
	qc.measure(qubit, qubit)
    # add the measurement by connecting qubits to classical bits
    return qc

dj_circuit = lab1_ex8(oracle, n)
dj_circuit.draw('mpl')
</pre>
</div>


<figure id="orga30a20c">
<img src="./.ob-jupyter/b6b517368465848ffa7a4d07db5a2570b614219b.png" alt="b6b517368465848ffa7a4d07db5a2570b614219b.png">

</figure>

<p>
At this point the second single qubit register may be ignored. Applying a Hadamard gate to each qubit in the first register yields the state:
        $$
</p>
\begin{aligned}
    \lvert \psi_3 \rangle 
        & = \frac{1}{2^n}\sum_{x=0}^{2^n-1}(-1)^{f(x)}
            \left[ \sum_{y=0}^{2^n-1}(-1)^{x \cdot y} 
            \vert y \rangle \right] \\
        & = \frac{1}{2^n}\sum_{y=0}^{2^n-1}
            \left[ \sum_{x=0}^{2^n-1}(-1)^{f(x)+x \cdot y} \right]
            \vert y \rangle,
\end{aligned}
<p>
$$
</p>

<p>
where \(x \cdot y = x_0y_0 \oplus x_1y_1 \oplus \ldots \oplus x_{n-1}y_{n-1}\) is the sum of the bitwise product.
</p>

<p>
Let us now run the circuit including the measurement of the first register on the simulator:
</p>

<div class="org-src-container">
<pre class="src src-ipython">qasm_sim = Aer.get_backend('qasm_simulator')
transpiled_dj_circuit = transpile(dj_circuit, qasm_sim)
qobj = assemble(transpiled_dj_circuit)
results = qasm_sim.run(qobj).result()
answer = results.get_counts()
</pre>
</div>

<p>
/tmp/ipykernel_318198/434662112.py:4: DeprecationWarning: Using a qobj for run() is deprecated as of qiskit-aer 0.9.0 and will be removed no sooner than 3 months from that release date. Transpiled circuits should now be passed directly using `backend.run(circuits, **run_options).
  results = qasm_sim.run(qobj).result()
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_histogram(answer)
</pre>
</div>


<figure id="orge7b589d">
<img src="./.ob-jupyter/f2c2fe2cbfaca86c7f6f12759abb30234f419e95.png" alt="f2c2fe2cbfaca86c7f6f12759abb30234f419e95.png">

</figure>

<p>
As we learnt in the lecture, if the output is the zero bit string, we know that the oracle is constant. If it is any other bit string, we know that it is balanced. You may also check the other oracles by just changing the oracle number in the beginning where the oracle is defined!
</p>
</div>
</div>
</section>
</main>
<footer id="postamble" class="status">
<footer id="footer">
  <div class="footer-left">MIT Licensed © 2023 Alexandre Mahrach</div>
  <!-- <div class="footer-right"> -->
  <!--   <nav> -->
  <!--     <ul> -->
  <!--       <li><a href="/posts/posts.html"> Posts </a></li> -->
  <!--       <li><a href="/tutorials/tutorials.html"> Tutorials </a></li> -->
  <!--       <li><a href="/"> About </a></li> -->
  <!--     </ul> -->
  <!--   </nav> -->
  <!-- </div> -->
</footer>
</footer>
</body>
</html>
